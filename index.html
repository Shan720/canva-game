<!doctype html>
<html lang="zh-TW" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>俄羅斯方塊</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
    }
    
    * {
      box-sizing: border-box;
    }
  </style>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full m-0 p-0">
  <div id="app" class="w-full h-full flex items-center justify-center overflow-auto">
   <div class="text-center p-8 max-w-2xl w-full">
    <h1 id="gameTitle" class="mb-8 font-bold">俄羅斯方塊</h1>
    <div class="flex justify-center gap-8 mb-6 flex-wrap">
     <div class="text-left">
      <div id="scoreLabel" class="font-semibold mb-2">
       分數
      </div>
      <div id="scoreValue" class="text-3xl font-bold">
       0
      </div>
     </div>
     <div class="text-left">
      <div id="levelLabel" class="font-semibold mb-2">
       等級
      </div>
      <div id="levelValue" class="text-3xl font-bold">
       1
      </div>
     </div>
     <div class="text-left">
      <div id="linesLabel" class="font-semibold mb-2">
       行數
      </div>
      <div id="linesValue" class="text-3xl font-bold">
       0
      </div>
     </div>
    </div>
    <div class="flex justify-center mb-6">
     <canvas id="gameCanvas" width="300" height="600" class="border-4 shadow-lg"></canvas>
    </div>
    <div class="flex justify-center gap-4 mb-4 flex-wrap"><button id="startBtn" class="px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:opacity-90"> 開始遊戲 </button> <button id="pauseBtn" class="px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:opacity-90 opacity-50 cursor-not-allowed" disabled> 暫停 </button>
    </div>
    <div class="mb-4">
     <div class="flex justify-center mb-2"><button id="rotateBtn" class="px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:opacity-90 opacity-50 cursor-not-allowed" disabled> ↑ 旋轉 </button>
     </div>
     <div class="flex justify-center gap-3"><button id="leftBtn" class="px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:opacity-90 opacity-50 cursor-not-allowed" disabled> ← 左移 </button> <button id="downBtn" class="px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:opacity-90 opacity-50 cursor-not-allowed" disabled> ↓ 下落 </button> <button id="rightBtn" class="px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:opacity-90 opacity-50 cursor-not-allowed" disabled> 右移 → </button>
     </div>
    </div>
    <div id="gameOverMsg" class="text-2xl font-bold mb-4 hidden">
     遊戲結束！
    </div>
    <div id="controlsLabel" class="text-sm opacity-75">
     控制：← → 移動 | ��� 旋轉 | ↓ 快速下落
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "俄羅斯方塊",
      start_button_text: "開始遊戲",
      pause_button_text: "暫停",
      game_over_text: "遊戲結束！",
      background_color: "#1a1a2e",
      surface_color: "#16213e",
      text_color: "#eaeaea",
      primary_action_color: "#0f4c75",
      secondary_action_color: "#3282b8",
      font_family: "sans-serif",
      font_size: 16
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30;
    
    let board = [];
    let currentPiece = null;
    let currentX = 0;
    let currentY = 0;
    let score = 0;
    let level = 1;
    let lines = 0;
    let gameLoop = null;
    let isPaused = false;
    let isGameOver = false;
    let isPlaying = false;
    
    const SHAPES = [
      [[1,1,1,1]], // I
      [[1,1],[1,1]], // O
      [[0,1,0],[1,1,1]], // T
      [[1,0,0],[1,1,1]], // L
      [[0,0,1],[1,1,1]], // J
      [[0,1,1],[1,1,0]], // S
      [[1,1,0],[0,1,1]]  // Z
    ];
    
    const COLORS = ['#00f0f0', '#f0f000', '#a000f0', '#f0a000', '#0000f0', '#00f000', '#f00000'];
    
    function initBoard() {
      board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    }
    
    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }
    
    function drawBoard() {
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (board[y][x]) {
            drawBlock(x, y, COLORS[board[y][x] - 1]);
          }
        }
      }
      
      if (currentPiece) {
        for (let y = 0; y < currentPiece.shape.length; y++) {
          for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
              drawBlock(currentX + x, currentY + y, COLORS[currentPiece.color]);
            }
          }
        }
      }
    }
    
    function newPiece() {
      const shapeIndex = Math.floor(Math.random() * SHAPES.length);
      currentPiece = {
        shape: JSON.parse(JSON.stringify(SHAPES[shapeIndex])),
        color: shapeIndex
      };
      currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
      currentY = 0;
      
      if (collision()) {
        gameOver();
      }
    }
    
    function collision() {
      for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x]) {
            const newX = currentX + x;
            const newY = currentY + y;
            
            if (newX < 0 || newX >= COLS || newY >= ROWS) {
              return true;
            }
            if (newY >= 0 && board[newY][newX]) {
              return true;
            }
          }
        }
      }
      return false;
    }
    
    function merge() {
      for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x]) {
            if (currentY + y >= 0) {
              board[currentY + y][currentX + x] = currentPiece.color + 1;
            }
          }
        }
      }
    }
    
    function clearLines() {
      let linesCleared = 0;
      
      for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every(cell => cell !== 0)) {
          board.splice(y, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          y++;
        }
      }
      
      if (linesCleared > 0) {
        lines += linesCleared;
        score += linesCleared * 100 * level;
        level = Math.floor(lines / 10) + 1;
        updateDisplay();
      }
    }
    
    function moveDown() {
      if (!isPlaying || isPaused || isGameOver) return;
      
      currentY++;
      if (collision()) {
        currentY--;
        merge();
        clearLines();
        newPiece();
      }
      drawBoard();
    }
    
    function moveLeft() {
      if (!isPlaying || isPaused || isGameOver) return;
      
      currentX--;
      if (collision()) {
        currentX++;
      }
      drawBoard();
    }
    
    function moveRight() {
      if (!isPlaying || isPaused || isGameOver) return;
      
      currentX++;
      if (collision()) {
        currentX--;
      }
      drawBoard();
    }
    
    function rotate() {
      if (!isPlaying || isPaused || isGameOver) return;
      
      const rotated = currentPiece.shape[0].map((_, i) =>
        currentPiece.shape.map(row => row[i]).reverse()
      );
      const prev = currentPiece.shape;
      currentPiece.shape = rotated;
      if (collision()) {
        currentPiece.shape = prev;
      }
      drawBoard();
    }
    
    function updateDisplay() {
      document.getElementById('scoreValue').textContent = score;
      document.getElementById('levelValue').textContent = level;
      document.getElementById('linesValue').textContent = lines;
    }
    
    function gameOver() {
      isGameOver = true;
      isPlaying = false;
      clearInterval(gameLoop);
      gameLoop = null;
      document.getElementById('gameOverMsg').classList.remove('hidden');
      document.getElementById('startBtn').disabled = false;
      document.getElementById('startBtn').classList.remove('opacity-50', 'cursor-not-allowed');
      document.getElementById('pauseBtn').disabled = true;
      document.getElementById('pauseBtn').classList.add('opacity-50', 'cursor-not-allowed');
      
      // 禁用控制按鈕
      document.getElementById('leftBtn').disabled = true;
      document.getElementById('leftBtn').classList.add('opacity-50', 'cursor-not-allowed');
      document.getElementById('rotateBtn').disabled = true;
      document.getElementById('rotateBtn').classList.add('opacity-50', 'cursor-not-allowed');
      document.getElementById('rightBtn').disabled = true;
      document.getElementById('rightBtn').classList.add('opacity-50', 'cursor-not-allowed');
      document.getElementById('downBtn').disabled = true;
      document.getElementById('downBtn').classList.add('opacity-50', 'cursor-not-allowed');
    }
    
    function startGame() {
      initBoard();
      score = 0;
      level = 1;
      lines = 0;
      isPaused = false;
      isGameOver = false;
      isPlaying = true;
      updateDisplay();
      document.getElementById('gameOverMsg').classList.add('hidden');
      document.getElementById('startBtn').disabled = true;
      document.getElementById('startBtn').classList.add('opacity-50', 'cursor-not-allowed');
      document.getElementById('pauseBtn').disabled = false;
      document.getElementById('pauseBtn').classList.remove('opacity-50', 'cursor-not-allowed');
      
      // 啟用控制按鈕
      document.getElementById('leftBtn').disabled = false;
      document.getElementById('leftBtn').classList.remove('opacity-50', 'cursor-not-allowed');
      document.getElementById('rotateBtn').disabled = false;
      document.getElementById('rotateBtn').classList.remove('opacity-50', 'cursor-not-allowed');
      document.getElementById('rightBtn').disabled = false;
      document.getElementById('rightBtn').classList.remove('opacity-50', 'cursor-not-allowed');
      document.getElementById('downBtn').disabled = false;
      document.getElementById('downBtn').classList.remove('opacity-50', 'cursor-not-allowed');
      
      const config = window.elementSdk?.config || defaultConfig;
      document.getElementById('pauseBtn').textContent = config.pause_button_text || defaultConfig.pause_button_text;
      
      newPiece();
      drawBoard();
      
      if (gameLoop) {
        clearInterval(gameLoop);
      }
      
      gameLoop = setInterval(() => {
        if (isPlaying && !isPaused && !isGameOver) {
          moveDown();
        }
      }, Math.max(100, 600 - (level - 1) * 50));
    }
    
    function togglePause() {
      if (!isPlaying || isGameOver) return;
      
      isPaused = !isPaused;
      const config = window.elementSdk?.config || defaultConfig;
      document.getElementById('pauseBtn').textContent = isPaused ? '繼續' : (config.pause_button_text || defaultConfig.pause_button_text);
    }
    
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('leftBtn').addEventListener('click', moveLeft);
    document.getElementById('rotateBtn').addEventListener('click', rotate);
    document.getElementById('rightBtn').addEventListener('click', moveRight);
    document.getElementById('downBtn').addEventListener('click', moveDown);
    
    document.addEventListener('keydown', (e) => {
      if (!isPlaying || isGameOver || isPaused) return;
      
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        moveLeft();
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        moveRight();
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        moveDown();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        rotate();
      }
    });
    
    async function onConfigChange(config) {
      const baseSize = config.font_size || defaultConfig.font_size;
      const customFont = config.font_family || defaultConfig.font_family;
      const baseFontStack = 'sans-serif';
      
      const app = document.getElementById('app');
      app.style.backgroundColor = config.background_color || defaultConfig.background_color;
      
      const gameTitle = document.getElementById('gameTitle');
      gameTitle.textContent = config.game_title || defaultConfig.game_title;
      gameTitle.style.color = config.text_color || defaultConfig.text_color;
      gameTitle.style.fontSize = `${baseSize * 2}px`;
      gameTitle.style.fontFamily = `${customFont}, ${baseFontStack}`;
      
      const labels = ['scoreLabel', 'levelLabel', 'linesLabel', 'controlsLabel'];
      labels.forEach(id => {
        const el = document.getElementById(id);
        el.style.color = config.text_color || defaultConfig.text_color;
        el.style.fontSize = `${baseSize * 0.875}px`;
        el.style.fontFamily = `${customFont}, ${baseFontStack}`;
      });
      
      const values = ['scoreValue', 'levelValue', 'linesValue'];
      values.forEach(id => {
        const el = document.getElementById(id);
        el.style.color = config.text_color || defaultConfig.text_color;
        el.style.fontFamily = `${customFont}, ${baseFontStack}`;
      });
      
      const canvasEl = document.getElementById('gameCanvas');
      canvasEl.style.borderColor = config.surface_color || defaultConfig.surface_color;
      
      const startBtn = document.getElementById('startBtn');
      startBtn.textContent = config.start_button_text || defaultConfig.start_button_text;
      startBtn.style.backgroundColor = config.primary_action_color || defaultConfig.primary_action_color;
      startBtn.style.color = config.text_color || defaultConfig.text_color;
      startBtn.style.fontSize = `${baseSize}px`;
      startBtn.style.fontFamily = `${customFont}, ${baseFontStack}`;
      startBtn.style.display = 'inline-block';
      
      const pauseBtn = document.getElementById('pauseBtn');
      if (!isPaused) {
        pauseBtn.textContent = config.pause_button_text || defaultConfig.pause_button_text;
      }
      pauseBtn.style.backgroundColor = config.secondary_action_color || defaultConfig.secondary_action_color;
      pauseBtn.style.color = config.text_color || defaultConfig.text_color;
      pauseBtn.style.fontSize = `${baseSize}px`;
      pauseBtn.style.fontFamily = `${customFont}, ${baseFontStack}`;
      pauseBtn.style.display = 'inline-block';
      
      const controlButtons = ['leftBtn', 'rotateBtn', 'rightBtn', 'downBtn'];
      controlButtons.forEach(id => {
        const btn = document.getElementById(id);
        btn.style.backgroundColor = config.secondary_action_color || defaultConfig.secondary_action_color;
        btn.style.color = config.text_color || defaultConfig.text_color;
        btn.style.fontSize = `${baseSize * 0.875}px`;
        btn.style.fontFamily = `${customFont}, ${baseFontStack}`;
        btn.style.display = 'inline-block';
      });
      
      const gameOverMsg = document.getElementById('gameOverMsg');
      gameOverMsg.textContent = config.game_over_text || defaultConfig.game_over_text;
      gameOverMsg.style.color = config.text_color || defaultConfig.text_color;
      gameOverMsg.style.fontSize = `${baseSize * 1.5}px`;
      gameOverMsg.style.fontFamily = `${customFont}, ${baseFontStack}`;
    }
    
    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities: (config) => ({
          recolorables: [
            {
              get: () => config.background_color || defaultConfig.background_color,
              set: (value) => {
                config.background_color = value;
                window.elementSdk.setConfig({ background_color: value });
              }
            },
            {
              get: () => config.surface_color || defaultConfig.surface_color,
              set: (value) => {
                config.surface_color = value;
                window.elementSdk.setConfig({ surface_color: value });
              }
            },
            {
              get: () => config.text_color || defaultConfig.text_color,
              set: (value) => {
                config.text_color = value;
                window.elementSdk.setConfig({ text_color: value });
              }
            },
            {
              get: () => config.primary_action_color || defaultConfig.primary_action_color,
              set: (value) => {
                config.primary_action_color = value;
                window.elementSdk.setConfig({ primary_action_color: value });
              }
            },
            {
              get: () => config.secondary_action_color || defaultConfig.secondary_action_color,
              set: (value) => {
                config.secondary_action_color = value;
                window.elementSdk.setConfig({ secondary_action_color: value });
              }
            }
          ],
          borderables: [],
          fontEditable: {
            get: () => config.font_family || defaultConfig.font_family,
            set: (value) => {
              config.font_family = value;
              window.elementSdk.setConfig({ font_family: value });
            }
          },
          fontSizeable: {
            get: () => config.font_size || defaultConfig.font_size,
            set: (value) => {
              config.font_size = value;
              window.elementSdk.setConfig({ font_size: value });
            }
          }
        }),
        mapToEditPanelValues: (config) => new Map([
          ["game_title", config.game_title || defaultConfig.game_title],
          ["start_button_text", config.start_button_text || defaultConfig.start_button_text],
          ["pause_button_text", config.pause_button_text || defaultConfig.pause_button_text],
          ["game_over_text", config.game_over_text || defaultConfig.game_over_text]
        ])
      });
      
      onConfigChange(window.elementSdk.config);
    } else {
      onConfigChange(defaultConfig);
    }
    
    initBoard();
    drawBoard();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9aeb3e86e506843c',t:'MTc2NTg1NzMxNy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>